**1. Basic Concept**
Unit Testing is the process of testing the smallest unit of a program — usually a function or a method in a class — to ensure that it works correctly according to requirements.

**Goal:**
Detect errors in small parts of the source code before integrating them into a larger system.

**Example:**

```ts
function add(a: number, b: number): number {
  return a + b;
}
```

If you write a Unit Test for this function, you need to ensure:

* When calling `add(2, 3)` → the result must be `5`
* When calling `add(-1, 1)` → the result must be `0`

If the test runs and produces the expected result, the function works correctly.

**2. Why Write Unit Tests?**
Writing Unit Tests may take extra time initially, but it brings many benefits:

| Benefit             | Explanation                                                                   |
| ------------------- | ----------------------------------------------------------------------------- |
| Early bug detection | Easy to find bugs right when coding small functions                           |
| Lower fixing cost   | Small bugs found early won’t affect other parts                               |
| Easier maintenance  | When changing or upgrading code, tests help ensure old features aren’t broken |
| Automated testing   | Tests can run automatically after each commit                                 |
| Higher reliability  | Easier to detect potential issues before releasing to users                   |

**3. Characteristics of Unit Tests**

1. **Independent testing:**
   Each test should check only one small functionality, without depending on others.
2. **Fast and easy to run:**
   Unit Tests should execute quickly so they can be run frequently (e.g., on every file save or build).
3. **Automatable:**
   Use tools to automatically run all tests at once without manual steps.
4. **Clear results:**
   The test results should clearly show which functions “pass” and which “fail.”

**4. Structure of a Unit Test (AAA Pattern)**
A Unit Test usually has three steps, called **AAA**:

| Step | English Term | Meaning                                          | Example                     |
| ---- | ------------ | ------------------------------------------------ | --------------------------- |
| 1    | Arrange      | Prepare data, variables, and objects for testing | `const a = 2; const b = 3;` |
| 2    | Act          | Call the function or perform the action          | `const result = add(a, b);` |
| 3    | Assert       | Verify the result matches the expectation        | `expect(result).toBe(5);`   |

**Example with Jest** (a popular testing library for JavaScript/TypeScript):

```ts
// add.ts
export function add(a: number, b: number): number {
  return a + b;
}

// add.test.ts
import { add } from './add';

test('sum of 2 + 3 should be 5', () => {
  // Arrange
  const a = 2, b = 3;
  // Act
  const result = add(a, b);
  // Assert
  expect(result).toBe(5);
});
```

When running the test, if the result is correct, Jest will show “PASS”; if not, it will show “FAIL.”

**5. Common Unit Testing Tools**

| Language                | Popular Testing Libraries/Frameworks |
| ----------------------- | ------------------------------------ |
| JavaScript / TypeScript | Jest, Mocha, Vitest                  |
| Python                  | unittest, pytest                     |
| Java                    | JUnit                                |
| C#                      | NUnit, xUnit                         |
| PHP                     | PHPUnit                              |
| Go                      | Go test (built-in)                   |

For React or TypeScript projects, common tools include:

* **Jest** (for running tests)
* **React Testing Library** (for UI and user interaction testing)

**6. When to Write Unit Tests?**
You should write tests for parts that:

* Contain important logic (calculations, data processing, input validation, etc.)
* Are error-prone (complex conditions, loops, divisions, etc.)
* Are reused across multiple modules or functions

You should *not* write tests for:

* Simple UI display (e.g., showing text or images only)
* Code that directly depends on real APIs or databases (use *mock* or *fake data* instead)

**7. Advanced Unit Testing Techniques**

1. **Mocking:**
   Simulate (mock) data or function behavior so tests don’t depend on APIs or databases.

   Example:

   ```ts
   jest.mock('./api', () => ({
     fetchData: jest.fn(() => Promise.resolve({ name: 'Test' }))
   }));
   ```

2. **Test Coverage:**
   Measures how much of your code is tested.
   With Jest, run:

   ```
   npx jest --coverage
   ```

3. **Setup & Teardown:**
   Use `beforeEach()` or `afterEach()` to prepare or clean up data before/after each test.

   ```ts
   beforeEach(() => {
     console.log('Runs before each test');
   });

   afterEach(() => {
     console.log('Runs after each test');
   });
   ```

**8. Unit Testing Workflow in a Project**

1. Analyze the code logic to identify testable parts.
2. Break down functions or classes to make them easier to test.
3. Write test cases for each input-output scenario.
4. Run tests frequently (after every code change).
5. Automate tests by adding a script in `package.json`:

   ```json
   {
     "scripts": {
       "test": "jest"
     }
   }
   ```
6. Integrate tests into CI/CD pipelines (automatically run tests before deployment).

**Example:**

```ts
// calculator.ts
export function divide(a: number, b: number): number {
  if (b === 0) throw new Error('Cannot divide by zero');
  return a / b;
}

// calculator.test.ts
import { divide } from './calculator';

test('10 divided by 2 should be 5', () => {
  expect(divide(10, 2)).toBe(5);
});

test('dividing by zero should throw an error', () => {
  expect(() => divide(10, 0)).toThrow('Cannot divide by zero');
});
```

When running the tests:

```
PASS  calculator.test.ts
✓ 10 divided by 2 should be 5
✓ dividing by zero should throw an error
```

**9. Summary**

| Topic               | Summary                                    |
| ------------------- | ------------------------------------------ |
| Concept             | Testing individual small units of code     |
| Goal                | Detect bugs early, ensure code correctness |
| Test Structure      | Arrange → Act → Assert                     |
| Common Tools        | Jest, Mocha, JUnit, Pytest, xUnit          |
| Should Test         | Important logic, error-prone functions     |
| Shouldn’t Test      | Simple UI, real APIs                       |
| Advanced Techniques | Mocking, coverage, setup/teardown          |