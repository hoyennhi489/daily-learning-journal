### REDUX

Redux is a state management library for JavaScript applications, especially popular with React.

It helps you store all data in a single central place called the **store**, instead of letting each component manage its own local state.

**Example:**
You have several different components:

• Header displays the user’s name

• Navbar displays the avatar

• Profile page shows detailed information


All of them need user data → if each stores it separately, things can get messy.
Redux helps you keep the user data in one place, and all components can access it simultaneously.

### Why Redux Is Needed

React has local state, but in large applications it becomes difficult when many components need to share the same data.

| Situation                             | Normal React State | Redux                  |
| ------------------------------------- | ------------------ | ---------------------- |
| Managing state in a small component   | Good               | Not needed             |
| Sharing state between many components | Complex            | Easy                   |
| Deeply nested components              | Messy props        | Centralized management |
| Debugging and tracking changes        | Limited support    | Powerful DevTools      |

**Redux helps you:**

• Reduce prop drilling (passing props down many levels).

• Easily control the global data flow.

• Debug errors more efficiently.

### How Redux Works

Redux operates based on a **one-way data flow**:

```
UI (Component)
   ↓ dispatch(action)
Reducer (pure function)
   ↓ creates new state
Store (holds state)
   ↓
UI re-renders
```

### Main Components of Redux

| Component                   | Description                                                                |
| --------------------------- | -------------------------------------------------------------------------- |
| **Store**                   | Stores the entire state of the application                                 |
| **State**                   | The current data stored in the store                                       |
| **Action**                  | A message that describes what change you want to make                      |
| **Reducer**                 | A function that takes the old state and an action, and returns a new state |
| **Dispatch**                | Sends an action to the reducer                                             |
| **Subscribe / useSelector** | Tracks state changes to re-render the UI                                   |

### Installing Redux

First, you need a React project (created with Vite or CRA).
Then install Redux and React-Redux:

```bash
npm install redux react-redux
```

### Suggested Folder Structure

```
src/
├─ redux/
│  ├─ store.ts
│  ├─ actions.ts
│  ├─ reducer.ts
│  └─ types.ts (optional)
├─ App.tsx
└─ main.tsx
```

### Creating Basic Redux Components

#### (1) Create `actions.ts`

Actions are the “events” you send to request a state change.

```ts
// src/redux/actions.ts
export const increment = () => ({ type: 'INCREMENT' });
export const decrement = () => ({ type: 'DECREMENT' });
export const reset = () => ({ type: 'RESET' });
```

• `type` is a string describing the action (required).

• Actions can also carry additional data (**payload**).

**Example:**

```ts
export const addStudent = (name: string) => ({
  type: 'ADD_STUDENT',
  payload: name,
});
```

---

#### (2) Create `reducer.ts`

Reducers decide **how the state changes**.

```ts
// src/redux/reducer.ts
interface CounterState {
  count: number;
}

const initialState: CounterState = { count: 0 };

export const counterReducer = (
  state = initialState,
  action: { type: string; payload?: any }
) => {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 };
    case 'DECREMENT':
      return { count: state.count - 1 };
    case 'RESET':
      return { count: 0 };
    default:
      return state;
  }
};
```

**Explanation:**

• `counterReducer` receives the old state and an action.

• Based on `action.type`, it creates a new (immutable) state.

• Returns the new state for the UI to re-render.

---

#### (3) Create `store.ts`

The **store** is the central place that holds all state and manages reducers.

```ts
// src/redux/store.ts
import { createStore } from 'redux';
import { counterReducer } from './reducer';

export const store = createStore(counterReducer);
```

---

#### (4) Connect Redux with React

Wrap your application with the **Provider** component.

```tsx
// src/main.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import { Provider } from 'react-redux';
import { store } from './redux/store';
import App from './App';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <Provider store={store}>
    <App />
  </Provider>
);
```

### Using Redux in a Component

```tsx
// src/App.tsx
import React from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { increment, decrement, reset } from './redux/actions';

function App() {
  const count = useSelector((state: any) => state.count);
  const dispatch = useDispatch();

  return (
    <div style={{ textAlign: 'center', marginTop: '40px' }}>
      <h1>Basic Redux</h1>
      <h2>Count: {count}</h2>

      <button onClick={() => dispatch(decrement())}>–</button>
      <button onClick={() => dispatch(increment())}>+</button>
      <button onClick={() => dispatch(reset())}>Reset</button>
    </div>
  );
}

export default App;
```

### The Data Flow Cycle

1. The user clicks a button.
2. The component calls `dispatch(action)`.
3. The reducer receives the action and current state.
4. The reducer returns a new state.
5. The store saves the new state.
6. The component re-renders with the updated value.

### Example: Managing a Student List

**actions.ts**

```ts
export const addStudent = (name: string) => ({
  type: 'ADD_STUDENT',
  payload: name,
});

export const removeStudent = (index: number) => ({
  type: 'REMOVE_STUDENT',
  payload: index,
});
```

**reducer.ts**

```ts
interface StudentState {
  students: string[];
}

const initialState: StudentState = { students: [] };

export const studentReducer = (
  state = initialState,
  action: { type: string; payload?: any }
) => {
  switch (action.type) {
    case 'ADD_STUDENT':
      return { students: [...state.students, action.payload] };
    case 'REMOVE_STUDENT':
      return {
        students: state.students.filter((_, i) => i !== action.payload),
      };
    default:
      return state;
  }
};
```

**Component**

```tsx
import React, { useState } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { addStudent, removeStudent } from './redux/actions';

function StudentApp() {
  const [name, setName] = useState('');
  const students = useSelector((state: any) => state.students);
  const dispatch = useDispatch();

  return (
    <div style={{ textAlign: 'center', marginTop: 40 }}>
      <h2>Student List</h2>
      <input
        value={name}
        onChange={(e) => setName(e.target.value)}
        placeholder="Enter student name"
      />
      <button onClick={() => { dispatch(addStudent(name)); setName(''); }}>
        Add
      </button>

      <ul>
        {students.map((s: string, i: number) => (
          <li key={i}>
            {s}
            <button onClick={() => dispatch(removeStudent(i))}>Delete</button>
          </li>
        ))}
      </ul>
    </div>
  );
}

export default StudentApp;
```

### Advantages and Disadvantages of Basic Redux

**Advantages**

• Centralized state control.

• Easy debugging with Redux DevTools.

• Clear and predictable data flow.


**Disadvantages**

• Verbose syntax.

• Requires many separate files (actions, reducers, constants).

• You cannot mutate state directly (must clone instead).

### Summary

| Component       | Role                  | Keyword               |
| --------------- | --------------------- | --------------------- |
| **store**       | Holds the state       | `createStore`         |
| **action**      | Describes what to do  | `{ type, payload }`   |
| **reducer**     | Handles state updates | `switch(action.type)` |
| **dispatch**    | Sends an action       | `dispatch(action)`    |
| **useSelector** | Reads data from store | `state.xxx`           |
| **useDispatch** | Sends actions from UI | `dispatch(...)`       |